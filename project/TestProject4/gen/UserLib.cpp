// This file was automatically generated by gen.py at 10/30/2025, 01:43:59.
// Editing the contents of this file manually is not recommended and may result in an application crash.
#pragma once
#include "Omni.h"
#include "domain/Domain.h"
#include "scene/ScriptableEntity.h"
#include "userlib/UserLibraryCore.h"
#include "core/UUID.h"
#include <MurmurHash2/MurmurHash2.h>

#include "src/Player.h"
#include "src/RendererDomain.h"
#include "src/UserComponents.h"
#include "src/TestProject4.h"
#include "src/RayMarchDomain.h"

using namespace Omni;

using AllUserComponents =
ComponentGroup<
	UUIDComponent,
	NameComponent,
	TransformComponent,
	RelationshipComponent,
	SpriteRendererComponent,
	CameraComponent,
    BoundingBox,
	NativeScriptComponent,
	EnemyComponent,
	Sphere,
	Box,
	TexturedBox,
	Cylinder
>;

std::unordered_map<uint64_t, std::string>* g_Domains;
std::unordered_map<uint64_t, std::string>* g_RendererDomains;
std::unordered_map<uint64_t, Omni::ScriptSpecification>* g_Scripts;
std::unordered_map<uint64_t, Omni::ComponentSpecification>* g_Components;

// Hashes

uint64_t RayMarchDomain_Hash;

uint64_t TestDomain_Hash;

uint64_t PhysicsDomain_Hash;

uint64_t CustomRendererDomain_Hash;

uint64_t Player_Hash;
uint64_t Player_m_MoveSpeed_Hash;
uint64_t Player_m_LookSpeed_Hash;

uint64_t EnemyScript_Hash;
uint64_t EnemyScript_m_MoveSpeed_Hash;

uint64_t TestScript_Hash;
uint64_t TestScript_m_TestVar_Hash;
uint64_t TestScript_m_SuperVar_Hash;
uint64_t TestScript_m_TestVar3_Hash;
uint64_t TestScript_m_Testuint32_Hash;
uint64_t TestScript_m_Testuint64_Hash;
uint64_t TestScript_m_Super32_Hash;
uint64_t TestScript_m_Super64_Hash;
uint64_t TestScript_m_TestFloat_Hash;
uint64_t TestScript_m_TestDouble_Hash;
uint64_t TestScript_m_TestBool_Hash;
uint64_t TestScript_m_TestString_Hash;
uint64_t TestScript_m_SuperString_Hash;

uint64_t TestScript2_Hash;
uint64_t TestScript2_m_FixedUpdateCounter_Hash;

uint64_t MagicScript_Hash;

uint64_t MagicScript2_Hash;

uint64_t MagicScript3_Hash;

uint64_t MagicScript4_Hash;

uint64_t EnemyComponent_Hash;
uint64_t EnemyComponent_State_Hash;

uint64_t Sphere_Hash;
uint64_t Sphere_Blending_Hash;
uint64_t Sphere_Radius_Hash;
uint64_t Sphere_Red_Hash;
uint64_t Sphere_Green_Hash;
uint64_t Sphere_Blue_Hash;

uint64_t Box_Hash;
uint64_t Box_Blending_Hash;
uint64_t Box_Red_Hash;
uint64_t Box_Green_Hash;
uint64_t Box_Blue_Hash;

uint64_t TexturedBox_Hash;
uint64_t TexturedBox_Blending_Hash;
uint64_t TexturedBox_Red_Hash;
uint64_t TexturedBox_Green_Hash;
uint64_t TexturedBox_Blue_Hash;
uint64_t TexturedBox_TextureIndex_Hash;
uint64_t TexturedBox_TextureScale_Hash;

uint64_t Cylinder_Hash;
uint64_t Cylinder_Blending_Hash;
uint64_t Cylinder_Height_Hash;
uint64_t Cylinder_Red_Hash;
uint64_t Cylinder_Green_Hash;
uint64_t Cylinder_Blue_Hash;


// Hashes

extern "C" __declspec(dllexport) void Init()
{
	// Domains
	g_Domains = new std::unordered_map<uint64_t, std::string>();

	{
		std::string name = "RayMarchDomain";
		RayMarchDomain_Hash = MurmurHash64A(name.c_str(), name.length(), HASH_SEED);
		(*g_Domains)[RayMarchDomain_Hash] = name;
	}

	{
		std::string name = "TestDomain";
		TestDomain_Hash = MurmurHash64A(name.c_str(), name.length(), HASH_SEED);
		(*g_Domains)[TestDomain_Hash] = name;
	}

	{
		std::string name = "PhysicsDomain";
		PhysicsDomain_Hash = MurmurHash64A(name.c_str(), name.length(), HASH_SEED);
		(*g_Domains)[PhysicsDomain_Hash] = name;
	}

	// Domains

	// Renderers
	g_RendererDomains = new std::unordered_map<uint64_t, std::string>();

	{
		std::string name = "CustomRendererDomain";
		CustomRendererDomain_Hash = MurmurHash64A(name.c_str(), name.length(), HASH_SEED);
		(*g_RendererDomains)[CustomRendererDomain_Hash] = name;
	}

	// Renderers

	// Scripts
	g_Scripts = new std::unordered_map<uint64_t, Omni::ScriptSpecification>();

	{
		std::string name = "Player";
		Omni::ScriptSpecification spec = Omni::ScriptSpecification(name);

		{
			std::string varName = name + "_m_MoveSpeed";
			Player_m_MoveSpeed_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[Player_m_MoveSpeed_Hash] = { "m_MoveSpeed", Omni::ScriptVarType::TYPE_FLOAT };
		}

		{
			std::string varName = name + "_m_LookSpeed";
			Player_m_LookSpeed_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[Player_m_LookSpeed_Hash] = { "m_LookSpeed", Omni::ScriptVarType::TYPE_FLOAT };
		}

		Player_Hash = MurmurHash64A(name.c_str(), name.length(), HASH_SEED);
		(*g_Scripts)[Player_Hash] = spec;
	}

	{
		std::string name = "EnemyScript";
		Omni::ScriptSpecification spec = Omni::ScriptSpecification(name);

		{
			std::string varName = name + "_m_MoveSpeed";
			EnemyScript_m_MoveSpeed_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[EnemyScript_m_MoveSpeed_Hash] = { "m_MoveSpeed", Omni::ScriptVarType::TYPE_INT };
		}

		EnemyScript_Hash = MurmurHash64A(name.c_str(), name.length(), HASH_SEED);
		(*g_Scripts)[EnemyScript_Hash] = spec;
	}

	{
		std::string name = "TestScript";
		Omni::ScriptSpecification spec = Omni::ScriptSpecification(name);

		{
			std::string varName = name + "_m_TestVar";
			TestScript_m_TestVar_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[TestScript_m_TestVar_Hash] = { "m_TestVar", Omni::ScriptVarType::TYPE_INT };
		}

		{
			std::string varName = name + "_m_SuperVar";
			TestScript_m_SuperVar_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[TestScript_m_SuperVar_Hash] = { "m_SuperVar", Omni::ScriptVarType::TYPE_INT };
		}

		{
			std::string varName = name + "_m_TestVar3";
			TestScript_m_TestVar3_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[TestScript_m_TestVar3_Hash] = { "m_TestVar3", Omni::ScriptVarType::TYPE_INT };
		}

		{
			std::string varName = name + "_m_Testuint32";
			TestScript_m_Testuint32_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[TestScript_m_Testuint32_Hash] = { "m_Testuint32", Omni::ScriptVarType::TYPE_UINT32_T };
		}

		{
			std::string varName = name + "_m_Testuint64";
			TestScript_m_Testuint64_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[TestScript_m_Testuint64_Hash] = { "m_Testuint64", Omni::ScriptVarType::TYPE_UINT64_T };
		}

		{
			std::string varName = name + "_m_Super32";
			TestScript_m_Super32_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[TestScript_m_Super32_Hash] = { "m_Super32", Omni::ScriptVarType::TYPE_UINT32_T };
		}

		{
			std::string varName = name + "_m_Super64";
			TestScript_m_Super64_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[TestScript_m_Super64_Hash] = { "m_Super64", Omni::ScriptVarType::TYPE_UINT64_T };
		}

		{
			std::string varName = name + "_m_TestFloat";
			TestScript_m_TestFloat_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[TestScript_m_TestFloat_Hash] = { "m_TestFloat", Omni::ScriptVarType::TYPE_FLOAT };
		}

		{
			std::string varName = name + "_m_TestDouble";
			TestScript_m_TestDouble_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[TestScript_m_TestDouble_Hash] = { "m_TestDouble", Omni::ScriptVarType::TYPE_DOUBLE };
		}

		{
			std::string varName = name + "_m_TestBool";
			TestScript_m_TestBool_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[TestScript_m_TestBool_Hash] = { "m_TestBool", Omni::ScriptVarType::TYPE_BOOL };
		}

		{
			std::string varName = name + "_m_TestString";
			TestScript_m_TestString_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[TestScript_m_TestString_Hash] = { "m_TestString", Omni::ScriptVarType::TYPE_STRING };
		}

		{
			std::string varName = name + "_m_SuperString";
			TestScript_m_SuperString_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[TestScript_m_SuperString_Hash] = { "m_SuperString", Omni::ScriptVarType::TYPE_STRING };
		}

		TestScript_Hash = MurmurHash64A(name.c_str(), name.length(), HASH_SEED);
		(*g_Scripts)[TestScript_Hash] = spec;
	}

	{
		std::string name = "TestScript2";
		Omni::ScriptSpecification spec = Omni::ScriptSpecification(name);

		{
			std::string varName = name + "_m_FixedUpdateCounter";
			TestScript2_m_FixedUpdateCounter_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[TestScript2_m_FixedUpdateCounter_Hash] = { "m_FixedUpdateCounter", Omni::ScriptVarType::TYPE_UINT64_T };
		}

		TestScript2_Hash = MurmurHash64A(name.c_str(), name.length(), HASH_SEED);
		(*g_Scripts)[TestScript2_Hash] = spec;
	}

	{
		std::string name = "MagicScript";
		Omni::ScriptSpecification spec = Omni::ScriptSpecification(name);
		MagicScript_Hash = MurmurHash64A(name.c_str(), name.length(), HASH_SEED);
		(*g_Scripts)[MagicScript_Hash] = spec;
	}

	{
		std::string name = "MagicScript2";
		Omni::ScriptSpecification spec = Omni::ScriptSpecification(name);
		MagicScript2_Hash = MurmurHash64A(name.c_str(), name.length(), HASH_SEED);
		(*g_Scripts)[MagicScript2_Hash] = spec;
	}

	{
		std::string name = "MagicScript3";
		Omni::ScriptSpecification spec = Omni::ScriptSpecification(name);
		MagicScript3_Hash = MurmurHash64A(name.c_str(), name.length(), HASH_SEED);
		(*g_Scripts)[MagicScript3_Hash] = spec;
	}

	{
		std::string name = "MagicScript4";
		Omni::ScriptSpecification spec = Omni::ScriptSpecification(name);
		MagicScript4_Hash = MurmurHash64A(name.c_str(), name.length(), HASH_SEED);
		(*g_Scripts)[MagicScript4_Hash] = spec;
	}

	// Scripts

	// Components

	g_Components = new std::unordered_map<uint64_t, Omni::ComponentSpecification>();

	{
		std::string name = "EnemyComponent";
		Omni::ComponentSpecification spec = Omni::ComponentSpecification(name);

		{
			std::string varName = name + "_State";
			EnemyComponent_State_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[EnemyComponent_State_Hash] = { "State", Omni::ScriptVarType::TYPE_INT };
		}

		EnemyComponent_Hash = MurmurHash64A(name.c_str(), name.length(), HASH_SEED);
		(*g_Components)[EnemyComponent_Hash] = spec;
	}
	{
		std::string name = "Sphere";
		Omni::ComponentSpecification spec = Omni::ComponentSpecification(name);

		{
			std::string varName = name + "_Blending";
			Sphere_Blending_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[Sphere_Blending_Hash] = { "Blending", Omni::ScriptVarType::TYPE_FLOAT };
		}

		{
			std::string varName = name + "_Radius";
			Sphere_Radius_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[Sphere_Radius_Hash] = { "Radius", Omni::ScriptVarType::TYPE_FLOAT };
		}

		{
			std::string varName = name + "_Red";
			Sphere_Red_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[Sphere_Red_Hash] = { "Red", Omni::ScriptVarType::TYPE_FLOAT };
		}

		{
			std::string varName = name + "_Green";
			Sphere_Green_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[Sphere_Green_Hash] = { "Green", Omni::ScriptVarType::TYPE_FLOAT };
		}

		{
			std::string varName = name + "_Blue";
			Sphere_Blue_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[Sphere_Blue_Hash] = { "Blue", Omni::ScriptVarType::TYPE_FLOAT };
		}

		Sphere_Hash = MurmurHash64A(name.c_str(), name.length(), HASH_SEED);
		(*g_Components)[Sphere_Hash] = spec;
	}
	{
		std::string name = "Box";
		Omni::ComponentSpecification spec = Omni::ComponentSpecification(name);

		{
			std::string varName = name + "_Blending";
			Box_Blending_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[Box_Blending_Hash] = { "Blending", Omni::ScriptVarType::TYPE_FLOAT };
		}

		{
			std::string varName = name + "_Red";
			Box_Red_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[Box_Red_Hash] = { "Red", Omni::ScriptVarType::TYPE_FLOAT };
		}

		{
			std::string varName = name + "_Green";
			Box_Green_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[Box_Green_Hash] = { "Green", Omni::ScriptVarType::TYPE_FLOAT };
		}

		{
			std::string varName = name + "_Blue";
			Box_Blue_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[Box_Blue_Hash] = { "Blue", Omni::ScriptVarType::TYPE_FLOAT };
		}

		Box_Hash = MurmurHash64A(name.c_str(), name.length(), HASH_SEED);
		(*g_Components)[Box_Hash] = spec;
	}
	{
		std::string name = "TexturedBox";
		Omni::ComponentSpecification spec = Omni::ComponentSpecification(name);

		{
			std::string varName = name + "_Blending";
			TexturedBox_Blending_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[TexturedBox_Blending_Hash] = { "Blending", Omni::ScriptVarType::TYPE_FLOAT };
		}

		{
			std::string varName = name + "_Red";
			TexturedBox_Red_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[TexturedBox_Red_Hash] = { "Red", Omni::ScriptVarType::TYPE_FLOAT };
		}

		{
			std::string varName = name + "_Green";
			TexturedBox_Green_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[TexturedBox_Green_Hash] = { "Green", Omni::ScriptVarType::TYPE_FLOAT };
		}

		{
			std::string varName = name + "_Blue";
			TexturedBox_Blue_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[TexturedBox_Blue_Hash] = { "Blue", Omni::ScriptVarType::TYPE_FLOAT };
		}

		{
			std::string varName = name + "_TextureIndex";
			TexturedBox_TextureIndex_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[TexturedBox_TextureIndex_Hash] = { "TextureIndex", Omni::ScriptVarType::TYPE_FLOAT };
		}

		{
			std::string varName = name + "_TextureScale";
			TexturedBox_TextureScale_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[TexturedBox_TextureScale_Hash] = { "TextureScale", Omni::ScriptVarType::TYPE_FLOAT };
		}

		TexturedBox_Hash = MurmurHash64A(name.c_str(), name.length(), HASH_SEED);
		(*g_Components)[TexturedBox_Hash] = spec;
	}
	{
		std::string name = "Cylinder";
		Omni::ComponentSpecification spec = Omni::ComponentSpecification(name);

		{
			std::string varName = name + "_Blending";
			Cylinder_Blending_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[Cylinder_Blending_Hash] = { "Blending", Omni::ScriptVarType::TYPE_FLOAT };
		}

		{
			std::string varName = name + "_Height";
			Cylinder_Height_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[Cylinder_Height_Hash] = { "Height", Omni::ScriptVarType::TYPE_FLOAT };
		}

		{
			std::string varName = name + "_Red";
			Cylinder_Red_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[Cylinder_Red_Hash] = { "Red", Omni::ScriptVarType::TYPE_FLOAT };
		}

		{
			std::string varName = name + "_Green";
			Cylinder_Green_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[Cylinder_Green_Hash] = { "Green", Omni::ScriptVarType::TYPE_FLOAT };
		}

		{
			std::string varName = name + "_Blue";
			Cylinder_Blue_Hash = MurmurHash64A(varName.c_str(), varName.length(), HASH_SEED);
			spec.Variables[Cylinder_Blue_Hash] = { "Blue", Omni::ScriptVarType::TYPE_FLOAT };
		}

		Cylinder_Hash = MurmurHash64A(name.c_str(), name.length(), HASH_SEED);
		(*g_Components)[Cylinder_Hash] = spec;
	}
	// Components

}

extern "C" __declspec(dllexport) void SetImGuiContext(ImGuiContext* context)
{
	ImGui::SetCurrentContext(context);
}

extern "C" __declspec(dllexport) void* GetDomainList()
{
    return static_cast<void*>(g_Domains);
}

extern "C" __declspec(dllexport) void* GetRendererDomainList()
{
	return static_cast<void*>(g_RendererDomains);
}

extern "C" __declspec(dllexport) void* GetScriptList()
{
    return static_cast<void*>(g_Scripts);
}

extern "C" __declspec(dllexport) void* GetComponentList()
{
	return static_cast<void*>(g_Components);
}

extern "C" __declspec(dllexport) void* GetDomain(uint64_t domainID)
{
	if (domainID == RayMarchDomain_Hash) { return static_cast<void*>(new RayMarchDomain); }
	else if (domainID == TestDomain_Hash) { return static_cast<void*>(new TestDomain); }
	else if (domainID == PhysicsDomain_Hash) { return static_cast<void*>(new PhysicsDomain); }

	return nullptr;
}

extern "C" __declspec(dllexport) void* GetRendererDomain(uint64_t domainID)
{
	if (domainID == CustomRendererDomain_Hash) { return static_cast<void*>(new CustomRendererDomain); }

    return nullptr;
}

extern "C" __declspec(dllexport) void* GetScript(uint64_t scriptID)
{
	if (scriptID == Player_Hash) { return static_cast<void*>(new Player); }
	else if (scriptID == EnemyScript_Hash) { return static_cast<void*>(new EnemyScript); }
	else if (scriptID == TestScript_Hash) { return static_cast<void*>(new TestScript); }
	else if (scriptID == TestScript2_Hash) { return static_cast<void*>(new TestScript2); }
	else if (scriptID == MagicScript_Hash) { return static_cast<void*>(new MagicScript); }
	else if (scriptID == MagicScript2_Hash) { return static_cast<void*>(new MagicScript2); }
	else if (scriptID == MagicScript3_Hash) { return static_cast<void*>(new MagicScript3); }
	else if (scriptID == MagicScript4_Hash) { return static_cast<void*>(new MagicScript4); }

    return nullptr;
}

extern "C" __declspec(dllexport) void* GetScriptVar(uint64_t scriptID, void* script, uint64_t varID)
{
	if (scriptID == Player_Hash)
	{
		auto scriptableEntity = static_cast<Player*>(script);

		if (varID == Player_m_MoveSpeed_Hash) { return static_cast<void*>(&scriptableEntity->m_MoveSpeed); }
		else if (varID == Player_m_LookSpeed_Hash) { return static_cast<void*>(&scriptableEntity->m_LookSpeed); }
	}
	else if (scriptID == EnemyScript_Hash)
	{
		auto scriptableEntity = static_cast<EnemyScript*>(script);

		if (varID == EnemyScript_m_MoveSpeed_Hash) { return static_cast<void*>(&scriptableEntity->m_MoveSpeed); }
	}
	else if (scriptID == TestScript_Hash)
	{
		auto scriptableEntity = static_cast<TestScript*>(script);

		if (varID == TestScript_m_TestVar_Hash) { return static_cast<void*>(&scriptableEntity->m_TestVar); }
		else if (varID == TestScript_m_SuperVar_Hash) { return static_cast<void*>(&scriptableEntity->m_SuperVar); }
		else if (varID == TestScript_m_TestVar3_Hash) { return static_cast<void*>(&scriptableEntity->m_TestVar3); }
		else if (varID == TestScript_m_Testuint32_Hash) { return static_cast<void*>(&scriptableEntity->m_Testuint32); }
		else if (varID == TestScript_m_Testuint64_Hash) { return static_cast<void*>(&scriptableEntity->m_Testuint64); }
		else if (varID == TestScript_m_Super32_Hash) { return static_cast<void*>(&scriptableEntity->m_Super32); }
		else if (varID == TestScript_m_Super64_Hash) { return static_cast<void*>(&scriptableEntity->m_Super64); }
		else if (varID == TestScript_m_TestFloat_Hash) { return static_cast<void*>(&scriptableEntity->m_TestFloat); }
		else if (varID == TestScript_m_TestDouble_Hash) { return static_cast<void*>(&scriptableEntity->m_TestDouble); }
		else if (varID == TestScript_m_TestBool_Hash) { return static_cast<void*>(&scriptableEntity->m_TestBool); }
		else if (varID == TestScript_m_TestString_Hash) { return static_cast<void*>(&scriptableEntity->m_TestString); }
		else if (varID == TestScript_m_SuperString_Hash) { return static_cast<void*>(&scriptableEntity->m_SuperString); }
	}
	else if (scriptID == TestScript2_Hash)
	{
		auto scriptableEntity = static_cast<TestScript2*>(script);

		if (varID == TestScript2_m_FixedUpdateCounter_Hash) { return static_cast<void*>(&scriptableEntity->m_FixedUpdateCounter); }
	}

    return nullptr;
}

extern "C" __declspec(dllexport) void* GetScriptSpecs()
{
    std::vector<std::pair<uint64_t, std::vector<Omni::VariableSpecification>*>>* scriptSpecs = new std::vector<std::pair<uint64_t, std::vector<Omni::VariableSpecification>*>>();

	{
		std::vector<Omni::VariableSpecification>* varSpecs = new std::vector<Omni::VariableSpecification>();
		varSpecs->emplace_back((*g_Scripts)[Player_Hash].Variables[Player_m_MoveSpeed_Hash]);
		varSpecs->emplace_back((*g_Scripts)[Player_Hash].Variables[Player_m_LookSpeed_Hash]);
		scriptSpecs->emplace_back(std::make_pair(Player_Hash, varSpecs));
	}

	{
		std::vector<Omni::VariableSpecification>* varSpecs = new std::vector<Omni::VariableSpecification>();
		varSpecs->emplace_back((*g_Scripts)[EnemyScript_Hash].Variables[EnemyScript_m_MoveSpeed_Hash]);
		scriptSpecs->emplace_back(std::make_pair(EnemyScript_Hash, varSpecs));
	}

	{
		std::vector<Omni::VariableSpecification>* varSpecs = new std::vector<Omni::VariableSpecification>();
		varSpecs->emplace_back((*g_Scripts)[TestScript_Hash].Variables[TestScript_m_TestVar_Hash]);
		varSpecs->emplace_back((*g_Scripts)[TestScript_Hash].Variables[TestScript_m_SuperVar_Hash]);
		varSpecs->emplace_back((*g_Scripts)[TestScript_Hash].Variables[TestScript_m_TestVar3_Hash]);
		varSpecs->emplace_back((*g_Scripts)[TestScript_Hash].Variables[TestScript_m_Testuint32_Hash]);
		varSpecs->emplace_back((*g_Scripts)[TestScript_Hash].Variables[TestScript_m_Testuint64_Hash]);
		varSpecs->emplace_back((*g_Scripts)[TestScript_Hash].Variables[TestScript_m_Super32_Hash]);
		varSpecs->emplace_back((*g_Scripts)[TestScript_Hash].Variables[TestScript_m_Super64_Hash]);
		varSpecs->emplace_back((*g_Scripts)[TestScript_Hash].Variables[TestScript_m_TestFloat_Hash]);
		varSpecs->emplace_back((*g_Scripts)[TestScript_Hash].Variables[TestScript_m_TestDouble_Hash]);
		varSpecs->emplace_back((*g_Scripts)[TestScript_Hash].Variables[TestScript_m_TestBool_Hash]);
		varSpecs->emplace_back((*g_Scripts)[TestScript_Hash].Variables[TestScript_m_TestString_Hash]);
		varSpecs->emplace_back((*g_Scripts)[TestScript_Hash].Variables[TestScript_m_SuperString_Hash]);
		scriptSpecs->emplace_back(std::make_pair(TestScript_Hash, varSpecs));
	}

	{
		std::vector<Omni::VariableSpecification>* varSpecs = new std::vector<Omni::VariableSpecification>();
		varSpecs->emplace_back((*g_Scripts)[TestScript2_Hash].Variables[TestScript2_m_FixedUpdateCounter_Hash]);
		scriptSpecs->emplace_back(std::make_pair(TestScript2_Hash, varSpecs));
	}

	{
		scriptSpecs->emplace_back(std::make_pair(MagicScript_Hash, nullptr));
	}

	{
		scriptSpecs->emplace_back(std::make_pair(MagicScript2_Hash, nullptr));
	}

	{
		scriptSpecs->emplace_back(std::make_pair(MagicScript3_Hash, nullptr));
	}

	{
		scriptSpecs->emplace_back(std::make_pair(MagicScript4_Hash, nullptr));
	}


    return static_cast<void*>(scriptSpecs);
}

extern "C" __declspec(dllexport) void* GetUserComponent(uint64_t componentID)
{
	if (componentID == EnemyComponent_Hash) { return static_cast<void*>(new EnemyComponent); }
	else if (componentID == Sphere_Hash) { return static_cast<void*>(new Sphere); }
	else if (componentID == Box_Hash) { return static_cast<void*>(new Box); }
	else if (componentID == TexturedBox_Hash) { return static_cast<void*>(new TexturedBox); }
	else if (componentID == Cylinder_Hash) { return static_cast<void*>(new Cylinder); }

    return nullptr;
}

extern "C" __declspec(dllexport) bool HasUserComponent(uint64_t entity, void* scene, uint64_t componentID)
{
    Scene* scenePtr = static_cast<Scene*>(scene);
    Omni::Entity e = scenePtr->GetEntity(entity);

	if (componentID == EnemyComponent_Hash) { return e.HasComponent<EnemyComponent>(); }
	else if (componentID == Sphere_Hash) { return e.HasComponent<Sphere>(); }
	else if (componentID == Box_Hash) { return e.HasComponent<Box>(); }
	else if (componentID == TexturedBox_Hash) { return e.HasComponent<TexturedBox>(); }
	else if (componentID == Cylinder_Hash) { return e.HasComponent<Cylinder>(); }

    return false;
}

extern "C" __declspec(dllexport) void AddUserComponent(uint64_t entity, void* scene, uint64_t componentID)
{
    Scene* scenePtr = static_cast<Scene*>(scene);
    Omni::Entity e = scenePtr->GetEntity(entity);

	if (componentID == EnemyComponent_Hash) { e.AddComponent<EnemyComponent>(); }
	else if (componentID == Sphere_Hash) { e.AddComponent<Sphere>(); }
	else if (componentID == Box_Hash) { e.AddComponent<Box>(); }
	else if (componentID == TexturedBox_Hash) { e.AddComponent<TexturedBox>(); }
	else if (componentID == Cylinder_Hash) { e.AddComponent<Cylinder>(); }

}

extern "C" __declspec(dllexport) void RemoveUserComponent(uint64_t entity, void* scene, uint64_t componentID)
{
	Scene* scenePtr = static_cast<Scene*>(scene);
	Omni::Entity e = scenePtr->GetEntity(entity);

	if (componentID == EnemyComponent_Hash) { e.RemoveComponent<EnemyComponent>(); }
	else if (componentID == Sphere_Hash) { e.RemoveComponent<Sphere>(); }
	else if (componentID == Box_Hash) { e.RemoveComponent<Box>(); }
	else if (componentID == TexturedBox_Hash) { e.RemoveComponent<TexturedBox>(); }
	else if (componentID == Cylinder_Hash) { e.RemoveComponent<Cylinder>(); }

}

extern "C" __declspec(dllexport) void* GetUserComponentVar(uint64_t entity, void* scene, uint64_t componentID, uint64_t varID)
{
    Scene* scenePtr = static_cast<Scene*>(scene);
    Omni::Entity e = scenePtr->GetEntity(entity);

	if (componentID == EnemyComponent_Hash)
	{
		auto component = &e.GetComponent<EnemyComponent>();

		if (varID == EnemyComponent_State_Hash) { return static_cast<void*>(&component->State); }
	}
	else if (componentID == Sphere_Hash)
	{
		auto component = &e.GetComponent<Sphere>();

		if (varID == Sphere_Blending_Hash) { return static_cast<void*>(&component->Blending); }
		else if (varID == Sphere_Radius_Hash) { return static_cast<void*>(&component->Radius); }
		else if (varID == Sphere_Red_Hash) { return static_cast<void*>(&component->Red); }
		else if (varID == Sphere_Green_Hash) { return static_cast<void*>(&component->Green); }
		else if (varID == Sphere_Blue_Hash) { return static_cast<void*>(&component->Blue); }
	}
	else if (componentID == Box_Hash)
	{
		auto component = &e.GetComponent<Box>();

		if (varID == Box_Blending_Hash) { return static_cast<void*>(&component->Blending); }
		else if (varID == Box_Red_Hash) { return static_cast<void*>(&component->Red); }
		else if (varID == Box_Green_Hash) { return static_cast<void*>(&component->Green); }
		else if (varID == Box_Blue_Hash) { return static_cast<void*>(&component->Blue); }
	}
	else if (componentID == TexturedBox_Hash)
	{
		auto component = &e.GetComponent<TexturedBox>();

		if (varID == TexturedBox_Blending_Hash) { return static_cast<void*>(&component->Blending); }
		else if (varID == TexturedBox_Red_Hash) { return static_cast<void*>(&component->Red); }
		else if (varID == TexturedBox_Green_Hash) { return static_cast<void*>(&component->Green); }
		else if (varID == TexturedBox_Blue_Hash) { return static_cast<void*>(&component->Blue); }
		else if (varID == TexturedBox_TextureIndex_Hash) { return static_cast<void*>(&component->TextureIndex); }
		else if (varID == TexturedBox_TextureScale_Hash) { return static_cast<void*>(&component->TextureScale); }
	}
	else if (componentID == Cylinder_Hash)
	{
		auto component = &e.GetComponent<Cylinder>();

		if (varID == Cylinder_Blending_Hash) { return static_cast<void*>(&component->Blending); }
		else if (varID == Cylinder_Height_Hash) { return static_cast<void*>(&component->Height); }
		else if (varID == Cylinder_Red_Hash) { return static_cast<void*>(&component->Red); }
		else if (varID == Cylinder_Green_Hash) { return static_cast<void*>(&component->Green); }
		else if (varID == Cylinder_Blue_Hash) { return static_cast<void*>(&component->Blue); }
	}

    return nullptr;
}

extern "C" __declspec(dllexport) void SetUserComponentVar(uint64_t entity, void* scene, uint64_t componentID, uint64_t varID, void* data)
{
    Scene* scenePtr = static_cast<Scene*>(scene);
    Omni::Entity e = scenePtr->GetEntity(entity);

	if (componentID == EnemyComponent_Hash)
	{
		auto component = &e.GetComponent<EnemyComponent>();

		if (varID == EnemyComponent_State_Hash) { component->State = *static_cast<int*>(data); }
	}
	else if (componentID == Sphere_Hash)
	{
		auto component = &e.GetComponent<Sphere>();

		if (varID == Sphere_Blending_Hash) { component->Blending = *static_cast<float*>(data); }
		else if (varID == Sphere_Radius_Hash) { component->Radius = *static_cast<float*>(data); }
		else if (varID == Sphere_Red_Hash) { component->Red = *static_cast<float*>(data); }
		else if (varID == Sphere_Green_Hash) { component->Green = *static_cast<float*>(data); }
		else if (varID == Sphere_Blue_Hash) { component->Blue = *static_cast<float*>(data); }
	}
	else if (componentID == Box_Hash)
	{
		auto component = &e.GetComponent<Box>();

		if (varID == Box_Blending_Hash) { component->Blending = *static_cast<float*>(data); }
		else if (varID == Box_Red_Hash) { component->Red = *static_cast<float*>(data); }
		else if (varID == Box_Green_Hash) { component->Green = *static_cast<float*>(data); }
		else if (varID == Box_Blue_Hash) { component->Blue = *static_cast<float*>(data); }
	}
	else if (componentID == TexturedBox_Hash)
	{
		auto component = &e.GetComponent<TexturedBox>();

		if (varID == TexturedBox_Blending_Hash) { component->Blending = *static_cast<float*>(data); }
		else if (varID == TexturedBox_Red_Hash) { component->Red = *static_cast<float*>(data); }
		else if (varID == TexturedBox_Green_Hash) { component->Green = *static_cast<float*>(data); }
		else if (varID == TexturedBox_Blue_Hash) { component->Blue = *static_cast<float*>(data); }
		else if (varID == TexturedBox_TextureIndex_Hash) { component->TextureIndex = *static_cast<float*>(data); }
		else if (varID == TexturedBox_TextureScale_Hash) { component->TextureScale = *static_cast<float*>(data); }
	}
	else if (componentID == Cylinder_Hash)
	{
		auto component = &e.GetComponent<Cylinder>();

		if (varID == Cylinder_Blending_Hash) { component->Blending = *static_cast<float*>(data); }
		else if (varID == Cylinder_Height_Hash) { component->Height = *static_cast<float*>(data); }
		else if (varID == Cylinder_Red_Hash) { component->Red = *static_cast<float*>(data); }
		else if (varID == Cylinder_Green_Hash) { component->Green = *static_cast<float*>(data); }
		else if (varID == Cylinder_Blue_Hash) { component->Blue = *static_cast<float*>(data); }
	}

}

template<typename... Component>
static void CopyUserComponent(entt::registry& dst, entt::registry& src, const std::unordered_map<Omni::UUID, entt::entity>& enttMap)
{
	([&]()
		{
			auto view = src.view<Component>();
			for (auto srcEntity : view)
			{
				entt::entity dstEntity = enttMap.at(src.get<UUIDComponent>(srcEntity).id);

				auto& srcComponent = src.get<Component>(srcEntity);
				dst.emplace_or_replace<Component>(dstEntity, srcComponent);
			}
		}(), ...);
}

template<typename... Component>
static void CopyUserComponent(ComponentGroup<Component...>, entt::registry& dst, entt::registry& src, const std::unordered_map<Omni::UUID, entt::entity>& enttMap)
{
	CopyUserComponent<Component...>(dst, src, enttMap);
}

extern "C" __declspec(dllexport) void* CopyUserScene(void* other)
{
	Scene* otherScene = static_cast<Scene*>(other);
	Scene* newScene = new Scene();

	newScene->m_ViewportWidth = otherScene->m_ViewportWidth;
	newScene->m_ViewportHeight = otherScene->m_ViewportHeight;

	// TODO : Copy main camera

	auto& srcSceneRegistry = otherScene->m_Registry;
	auto& dstSceneRegistry = newScene->m_Registry;
	std::unordered_map<Omni::UUID, entt::entity> enttMap;

	// Create entities in new scene
	for (auto e : otherScene->m_SceneOrder)
	{
		Omni::UUID id = e.GetComponent<UUIDComponent>().id;
		const auto& name = e.GetComponent<NameComponent>().Name;
		Entity newEntity = newScene->CreateEntityWithUUID(id, name);
        newEntity.SetActive(e.IsActive());
		enttMap[id] = (entt::entity)newEntity;
	}

	// Copy all components except for UUIDComponent and NameComponent
	CopyUserComponent(AllUserComponents{}, dstSceneRegistry, srcSceneRegistry, enttMap);

	return static_cast<void*>(newScene);
}
